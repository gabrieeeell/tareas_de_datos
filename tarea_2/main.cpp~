#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <string>
#include <unistd.h>
#define NUMERO_MAX_OPCIONES 10
#define NUMERO_MAX_MEJORAS_DE_COMBATE 20
using namespace std;

struct Opciones {
  string accion;
  string descripcion;
  string efecto;
};

struct Eventos {
  string nombre;
  float probabilidad;
  int numero_opciones;
  string descripcion;
  Opciones opciones[NUMERO_MAX_OPCIONES];
};

struct Habitacion {
  int numero;
  string nombre;
  string descripcion;
  string tipo;
};

struct NodoMapa {
  Habitacion habitacion;
  NodoMapa *hijo1 = nullptr;
  NodoMapa *hijo2 = nullptr;
  NodoMapa *hijo3 = nullptr;
};

struct arco {
  int desde;
  int hacia;
};

struct enemigo {
  string nombre;
  int vida;
  int ataque;
  float precision;
  float probabilidad;
};

class Jugador {
private:
  int vida;
  int ataque;
  float precision;
  int recuperacion;
};

void mostrar_generacion_texto(string texto) {
  for (int i = 0; i < texto.length(); i++) {
    cout << texto[i];
    cout.flush();  // Sin esto el texto no se muestra hasta el salto de linea
    usleep(25000); // 0.025 segundos
  }
  cout << "\n";
};

void texto_elegir_siguiente_sala(NodoMapa *&nodo_habitacion_actual) {
  NodoMapa *siguientes_habitaciones[3] = {
      nullptr, nullptr, nullptr}; // Ya que es un arbol ternario
  int siguiente_habitacion_index = 0;
  if (nodo_habitacion_actual->hijo1 != nullptr) {
    siguientes_habitaciones[siguiente_habitacion_index++] =
        nodo_habitacion_actual->hijo1;
  }
  if (nodo_habitacion_actual->hijo2 != nullptr) {
    siguientes_habitaciones[siguiente_habitacion_index++] =
        nodo_habitacion_actual->hijo2;
  }
  if (nodo_habitacion_actual->hijo3 != nullptr) {
    siguientes_habitaciones[siguiente_habitacion_index] =
        nodo_habitacion_actual->hijo3;
  }
  mostrar_generacion_texto(
      "A donde quieres ir?\n1. " +
      siguientes_habitaciones[0]->habitacion.nombre +
      (siguientes_habitaciones[1] != nullptr
           ? "2. " + siguientes_habitaciones[1]->habitacion.nombre
           : "") +
      (siguientes_habitaciones[2] != nullptr
           ? "3. " + siguientes_habitaciones[2]->habitacion.nombre
           : ""));
  string opcion;
  cin >> opcion;
}

string mejoras_de_combate[NUMERO_MAX_MEJORAS_DE_COMBATE];
// *& Por lo que usa una referencia al puntero, no una copia del puntero
void leer_mapa(string nombre_archivo, NodoMapa *&nodos_habitaciones) {
  int total_habitaciones;
  string linea;
  ifstream mapa(nombre_archivo);
  if (!mapa.is_open()) {
    cout << "No se pudo abrir el archivo" << endl;
    return;
  }

  while (getline(mapa, linea)) {
    if (linea == "HABITACIONES") {
      getline(mapa, linea);
      total_habitaciones = stoi(linea); // stoi transforma la linea a un int
      nodos_habitaciones = new NodoMapa[total_habitaciones];

      for (int i = 0; i < total_habitaciones; i++) {
        getline(mapa, linea);

        size_t espacio = linea.find(" ");
        nodos_habitaciones[i].habitacion.numero = stoi(linea.substr(
            0, espacio)); // substr(posicion, total de caracteres a sustraer)

        size_t parentesis = linea.find("(");
        nodos_habitaciones[i].habitacion.nombre =
            linea.substr(espacio + 1, parentesis - espacio - 2);

        size_t parentesis_final = linea.find(")");
        nodos_habitaciones[i].habitacion.tipo =
            linea.substr(parentesis + 1, parentesis_final - parentesis - 1);

        getline(mapa, linea);
        nodos_habitaciones[i].habitacion.descripcion = linea;
        if (true) {
        }
      }
      cout << "oebe" << endl;
    }

    else if (linea == "ARCOS") {
      int total_arcos;
      getline(mapa, linea);
      total_arcos = stoi(linea);
      arco *arcos_mapa = new arco[total_arcos];

      for (int a = 0; a < total_arcos; a++) {
        getline(mapa, linea);

        size_t espacio = linea.find(" ");
        int desde = stoi(linea.substr(0, espacio));
        size_t flecha = linea.find("->");
        int hacia = stoi(linea.substr(flecha + 2));
        if (nodos_habitaciones[desde].hijo1 == nullptr) {
          nodos_habitaciones[desde].hijo1 = &(nodos_habitaciones[hacia]);
        } else if (nodos_habitaciones[desde].hijo2 == nullptr) {
          nodos_habitaciones[desde].hijo2 = &(nodos_habitaciones[hacia]);
        } else {
          nodos_habitaciones[desde].hijo3 = &(nodos_habitaciones[hacia]);
        }
      }
    }

    else if (linea == "ENEMIGOS") {
      int total_enemigos;
      getline(mapa, linea);
      total_enemigos = stoi(linea);
      enemigo *enemigos_mapa = new enemigo[total_enemigos];

      for (int b = 0; b < total_enemigos; b++) {
        getline(mapa, linea);

        size_t separador1 = linea.find("|");
        size_t separador2 = linea.find("|", separador1 + 1);
        size_t separador3 = linea.find("|", separador2 + 1);
        size_t separador4 = linea.find("|", separador3 + 1);

        enemigos_mapa[b].nombre = linea.substr(0, separador1);
        enemigos_mapa[b].vida =
            stoi(linea.substr(separador1 + 7, separador2 - separador1 - 2));
        enemigos_mapa[b].ataque =
            stoi(linea.substr(separador2 + 8, separador3 - (separador2 + 8)));
        enemigos_mapa[b].precision =
            stof(linea.substr(separador3 + 12, separador4 - (separador3 + 12)));
        enemigos_mapa[b].probabilidad = stof(linea.substr(separador4 + 14));
      }
    } else if (linea == "EVENTOS") {
      int total_eventos;
      getline(mapa, linea);
      total_eventos = stoi(linea);
      Eventos *eventos_mapa = new Eventos[total_eventos];

      for (int c = 0; c < total_eventos; c++) { // c++ que chistoso miau
        getline(mapa, linea);                   // se ubica en los &
        getline(mapa, linea);                   // nombre de los eventos
        eventos_mapa[c].nombre = linea;
        getline(mapa, linea); // probabilidad de aparicion

        size_t espacio_probabilidad = linea.find(" ");
        eventos_mapa[c].probabilidad =
            stof(linea.substr(espacio_probabilidad + 1));
        getline(mapa, linea);
        eventos_mapa[c].descripcion = linea;
        getline(mapa, linea);
        int num_opcion = 0;
        do {
          eventos_mapa[c].opciones[num_opcion].accion = linea.substr(3);
          getline(mapa, linea);
          eventos_mapa[c].opciones[num_opcion].descripcion = linea;
          getline(mapa, linea);
          eventos_mapa[c].opciones[num_opcion].efecto = linea;
          num_opcion++;
          getline(mapa, linea);
        } while (linea != "&");
      }
    } else if (linea == "MEJORAS DE COMBATE") {
      getline(mapa, linea);
      int indice_mejoras_de_combate = 0;
      while (linea != "FIN DE ARCHIVO") {
        mejoras_de_combate[indice_mejoras_de_combate] = linea;
        getline(mapa, linea);
      }
    }
  }

  // NO OLVIDAR BORRAR MEMORIA CAUSA //

  mapa.close();
}

int main() {

  srand(time(0)); // Esta linea es para generar una seed aleatoria para los
                  // numeros random

  int random_number = rand();
  NodoMapa *nodos_habitaciones;
  leer_mapa("ejemplo.map", nodos_habitaciones);
  NodoMapa *nodo_habitacion_actual = &nodos_habitaciones[0];
  mostrar_generacion_texto(nodo_habitacion_actual->habitacion.descripcion);
  sleep(1);
  do {
    texto_elegir_siguiente_sala(nodo_habitacion_actual);

  } while (nodo_habitacion_actual->hijo1 != nullptr ||
           nodo_habitacion_actual->hijo2 != nullptr ||
           nodo_habitacion_actual->hijo3 != nullptr);

  return 0;
}
