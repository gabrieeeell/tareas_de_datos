#include <cstddef>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <iostream>
#include <mutex>
#include <string>
#include <unistd.h>
#define NUMERO_MAX_OPCIONES 10
#define NUMERO_MAX_MEJORAS_DE_COMBATE 20
using namespace std;

struct Opciones {
  string accion;
  string descripcion;
  string efecto;
};

struct Eventos {
  string nombre;
  float probabilidad;
  int numero_opciones;
  string descripcion;
  Opciones opciones[NUMERO_MAX_OPCIONES];
};

struct Habitacion {
  int numero;
  string nombre;
  string descripcion;
  string tipo;
};

struct NodoMapa {
  Habitacion habitacion;
  NodoMapa *hijo1 = nullptr;
  NodoMapa *hijo2 = nullptr;
  NodoMapa *hijo3 = nullptr;
};

struct enemigo {
  string nombre;
  int vida;
  int ataque;
  float precision;
  float probabilidad;
};

struct Jugador {
  int vida;
  int ataque;
  float precision;
  int recuperacion;
};

struct nodo_cola {
  Jugador *jugador_nodo = nullptr;
  enemigo *enemigo_nodo = nullptr;
  nodo_cola *next = nullptr;
};

// Variables globales

int total_enemigos;
enemigo *enemigos_mapa;
string mejoras_de_combate[NUMERO_MAX_MEJORAS_DE_COMBATE];
int indice_mejoras_de_combate = 0;

class Cola_turnos {
  nodo_cola *frente;
  nodo_cola *final_cola;
  int longitud;

public:
  Cola_turnos();
  int length();
  void queue(nodo_cola *nuevo_nodo);
  nodo_cola *
  dequeue(); // dequeue sera implementado tal que devuelve el frontvalue en vez
             // de tener una función aparte para esto
};

Cola_turnos::Cola_turnos() {
  frente = final_cola = nullptr;
  longitud = 0;
};

void Cola_turnos::queue(nodo_cola *nuevo_nodo) {
  if (longitud == 0) {
    frente = final_cola = nuevo_nodo;
  } else {
    final_cola->next = nuevo_nodo;
    final_cola = nuevo_nodo;
  }
  longitud++;
}

nodo_cola *Cola_turnos::dequeue() {
  if (longitud == 0)
    return nullptr;

  nodo_cola *aux = frente;
  frente = frente->next;
  longitud--;
  return aux;
}

int Cola_turnos::length() { return longitud; }

void mostrar_generacion_texto(string texto, bool saltar_linea = true) {
  for (int i = 0; i < texto.length(); i++) {
    cout << texto[i];
    cout.flush();  // Sin esto el texto no se muestra hasta el salto de linea
    usleep(25000); // 25000 =  0.025 segundos
  }
  if (saltar_linea)
    cout << "\n";
};

/* ****
*
*   void manejar_mejoras_de_combate
******
*
*  Primero se le muestran las opciones al jugador
******
*
Input :
*
*   Jugador *jugador : Puntero al struct del jugador
*   (notar que las mejoras de combate son una variable global por lo que no se
*   incluye como parametro)
*
******
*   Esta función no tiene returns, las mejoras se manejan solo en la función
**** */
void manejar_mejoras_de_combate(Jugador *jugador) {
  mostrar_generacion_texto("Debes decidir: ");
  for (int i = 0; i < indice_mejoras_de_combate; i++) {

    // Aca uso substr para leer la palabra que esta después del primer
    // espacio de la linea
    string atributo = mejoras_de_combate[i].substr(
        mejoras_de_combate[i].find(" ") + 1,
        mejoras_de_combate[i].length() - mejoras_de_combate[i].find(" "));
    string cantidad_atributo =
        mejoras_de_combate[i].substr(1, mejoras_de_combate[i].find(" ") - 1);

    mostrar_generacion_texto("\t" + to_string(i) + ". Aumentar " +
                             (char)tolower(atributo[0]) + atributo.substr(1) +
                             " en " + cantidad_atributo + ".");
  }

  string eleccion_usuario;

  cin >> eleccion_usuario;

  string atributo = mejoras_de_combate[stoi(eleccion_usuario)].substr(
      mejoras_de_combate[stoi(eleccion_usuario)].find(" ") + 1,
      mejoras_de_combate[stoi(eleccion_usuario)].length() -
          mejoras_de_combate[stoi(eleccion_usuario)].find(" "));

  string cantidad_atributo = mejoras_de_combate[stoi(eleccion_usuario)].substr(
      1, mejoras_de_combate[stoi(eleccion_usuario)].find(" ") - 1);
  if (atributo == "Precision") {
    jugador->precision += stof(cantidad_atributo);
    mostrar_generacion_texto("Tu precisión aumento en " + cantidad_atributo +
                             "!");
  } else if (atributo == "Vida") {
    jugador->vida += stoi(cantidad_atributo);
    mostrar_generacion_texto("Recuperaste " + cantidad_atributo + " de vida!");
  } else {
    if (atributo == "ataque")
      jugador->ataque += stoi(cantidad_atributo);
    if (atributo == "recuperacion")
      jugador->recuperacion += stoi(cantidad_atributo);
    mostrar_generacion_texto("Tu " + atributo + " aumento en " +
                             cantidad_atributo + "!");
  }
};

void empezar_combate(Jugador *jugador, int total_enemigos,
                     enemigo *enemigos_mapa) {
  // elegir cantidad enemigos (maximo 4)
  int rng_enemigo = rand() % 101;
  int total_enemigos_este_combate;
  if (rng_enemigo <= 35) {
    total_enemigos_este_combate = 1;
  } else if (rng_enemigo <= 70) {
    total_enemigos_este_combate = 2;
  } else if (rng_enemigo <= 90) {
    total_enemigos_este_combate = 3;
  } else {
    total_enemigos_este_combate = 4;
  }
  nodo_cola *enemigos_este_combate[total_enemigos_este_combate];
  for (int i = 0; i < total_enemigos_este_combate; i++) {
    int rng_seleccion_enemigo =
        rand() % 10001; // Simula porcentajes de hasta centesimales (0.01%),
                        // tal que "10000 = 100%", tambien para que esto
                        // funcione, todos los porcentajes que representados
                        // decimalmente se tendran que multiplicar por 10000
    int porcentaje_acumulado = 0;
    for (int x = 0; x < total_enemigos; x++) {
      if (porcentaje_acumulado < rng_seleccion_enemigo &&
          rng_seleccion_enemigo < (porcentaje_acumulado +
                                   (enemigos_mapa[x].probabilidad * 10000))) {
        enemigos_este_combate[i] =
            new nodo_cola{nullptr, new enemigo{enemigos_mapa[x]}, nullptr};
        break;
      }
      porcentaje_acumulado += enemigos_mapa[x].probabilidad * 10000;
      // Al usar new, estoy creando una nueva instancia del enemigo, en vez de
      // hacer una referencia al "original"
    }
  }
  nodo_cola *nodo_jugador = new nodo_cola{jugador, nullptr, nullptr};
  // Aca uso directamente la referencia al jugador,
  // ya que no quiero hacer un clon de el
  for (int i = 0; i < total_enemigos_este_combate; i++) {
    mostrar_generacion_texto(enemigos_este_combate[i]->enemigo_nodo->nombre,
                             false);
    if (i < total_enemigos_este_combate - 2) {
      mostrar_generacion_texto(", ", false);
    } else if (i == (total_enemigos_este_combate - 2)) {
      mostrar_generacion_texto("y ", false);
    } else {
      mostrar_generacion_texto("!");
    }
  }
  // Se agregan el jugador y los enemigos a la cola, estos fueron agregados a
  // un struct de nodo aparte, para que asi todos los elementos de la cola
  // puedan tener el mismo tipo

  Cola_turnos turnos;
  turnos.queue(nodo_jugador);
  for (int i = 0; i < total_enemigos_este_combate; i++) {
    turnos.queue(enemigos_este_combate[i]);
  }

  // Ciclo principal del combate
  // La cola turnos solo alcanza longitud 1 cuando queda unicamente el jugador
  // con vida

  while (turnos.length() > 1 && jugador->vida > 0) {
    // Mostrar nombres jugador y enemigos
    mostrar_generacion_texto("Jugador", false);
    for (int i = 0; i < total_enemigos_este_combate; i++) {
      mostrar_generacion_texto(
          " | " + enemigos_este_combate[i]->enemigo_nodo->nombre, false);
    }
    cout << endl;
    // Mostrar vidas jugador y enemigos

    mostrar_generacion_texto(to_string(nodo_jugador->jugador_nodo->vida),
                             false);
    for (int i = 0; i < total_enemigos_este_combate; i++) {
      mostrar_generacion_texto(
          " | " + (enemigos_este_combate[i]->enemigo_nodo->vida > 0
                       ? to_string(enemigos_este_combate[i]->enemigo_nodo->vida)
                       : "X"),
          false);
    }
    cout << endl;

    // Ataque del combate

    nodo_cola *jugador_o_enemigo_que_ataca = turnos.dequeue();

    if (jugador_o_enemigo_que_ataca->enemigo_nodo == nullptr) {

      // Significa que esta atacando un jugador

      if (rand() % 10001 > jugador->precision * 10000) {
        mostrar_generacion_texto("Jugador falla!");
      } else {
        // Como tanto la cola como el array para los enemigos trabajan
        // con las direcciones de memoria de los mismos enemigos, puedo
        // usar la que mas me convenga. Para este caso determine que el
        // jugador ataca al primer enemigo del array que siga vivo

        for (int i = 0; i < total_enemigos_este_combate; i++) {
          if (enemigos_este_combate[i]->enemigo_nodo->vida > 0) {
            enemigos_este_combate[i]->enemigo_nodo->vida -= jugador->ataque;
            mostrar_generacion_texto(
                "Jugador golpea a " +
                enemigos_este_combate[i]->enemigo_nodo->nombre + " por " +
                to_string(jugador->ataque) + " de daño!");
            break;
          }
        }
      }
      turnos.queue(nodo_jugador);
    } else {

      // Ataca enemigo, el cual podria estar muerto y seguir en la cola
      // por lo que hay que verificar

      if (jugador_o_enemigo_que_ataca->enemigo_nodo->vida <= 0) {
        continue;
      } else {

        if (rand() % 10001 >
            jugador_o_enemigo_que_ataca->enemigo_nodo->precision * 10000) {
          mostrar_generacion_texto(
              jugador_o_enemigo_que_ataca->enemigo_nodo->nombre + " falla!\n");
        } else {
          jugador->vida -= jugador_o_enemigo_que_ataca->enemigo_nodo->ataque;
          mostrar_generacion_texto(
              jugador_o_enemigo_que_ataca->enemigo_nodo->nombre +
              " golpea a Jugador por " +
              to_string(jugador_o_enemigo_que_ataca->enemigo_nodo->ataque) +
              " de daño!");
        }
        turnos.queue(jugador_o_enemigo_que_ataca);
      }
    }
  }

  if (jugador->vida > 0) {
    // Jugador gano
    mostrar_generacion_texto("Has sobrevivido el combate!");
    mostrar_generacion_texto("Recuperas " + to_string(jugador->recuperacion) +
                             " de vida tras el combate.");
    manejar_mejoras_de_combate(jugador);

  } else {
    // jugador murio
    mostrar_generacion_texto("Jugador", false);
    for (int i = 0; i < total_enemigos_este_combate; i++) {
      mostrar_generacion_texto(
          " | " + enemigos_este_combate[i]->enemigo_nodo->nombre, false);
    }
    cout << endl;
    // Ahora hay que considerar que el jugador podria estar muerto

    mostrar_generacion_texto(
        jugador->vida > 0 ? (to_string(jugador->vida)) : "X", false);
    for (int i = 0; i < total_enemigos_este_combate; i++) {
      mostrar_generacion_texto(
          " | " + (enemigos_este_combate[i]->enemigo_nodo->vida > 0
                       ? to_string(enemigos_este_combate[i]->enemigo_nodo->vida)
                       : "X"),
          false);
    }
    cout << endl;
  }
};

void texto_elegir_siguiente_sala(NodoMapa *&nodo_habitacion_actual) {
  NodoMapa *siguientes_habitaciones[3] = {
      nullptr, nullptr, nullptr}; // Ya que es un arbol ternario
  int siguiente_habitacion_index = 0;
  if (nodo_habitacion_actual->hijo1 != nullptr) {
    siguientes_habitaciones[siguiente_habitacion_index++] =
        nodo_habitacion_actual->hijo1;
  }
  if (nodo_habitacion_actual->hijo2 != nullptr) {
    siguientes_habitaciones[siguiente_habitacion_index++] =
        nodo_habitacion_actual->hijo2;
  }
  if (nodo_habitacion_actual->hijo3 != nullptr) {
    siguientes_habitaciones[siguiente_habitacion_index++] =
        nodo_habitacion_actual->hijo3;
  }
  mostrar_generacion_texto(
      "A donde quieres ir?\n1. " +
      siguientes_habitaciones[0]->habitacion.nombre +
      (siguientes_habitaciones[1] != nullptr
           ? "\n2. " + siguientes_habitaciones[1]->habitacion.nombre
           : "") +
      (siguientes_habitaciones[2] != nullptr
           ? "\n3. " + siguientes_habitaciones[2]->habitacion.nombre
           : ""));
  string opcion = "Lo que no te mate, te infecta wajajaj";

  while (opcion != "1" && opcion != "2" && opcion != "3" ||
         opcion == "3" && siguiente_habitacion_index < 3 ||
         opcion == "2" && siguiente_habitacion_index < 2) {
    if (opcion != "Lo que no te mate, te infecta wajajaj") {
      cout << "Por favor elija una opción valida" << endl;
    }
    cin >> opcion;
  }
  nodo_habitacion_actual = siguientes_habitaciones[stoi(opcion) - 1];
}

// *& Por lo que usa una referencia al puntero, no una copia del puntero

void leer_mapa(string nombre_archivo, NodoMapa *&nodos_habitaciones) {
  int total_habitaciones;
  string linea;
  ifstream mapa(nombre_archivo);
  if (!mapa.is_open()) {
    cout << "No se pudo abrir el archivo" << endl;
    return;
  }

  while (getline(mapa, linea)) {
    if (linea == "HABITACIONES") {
      getline(mapa, linea);
      total_habitaciones = stoi(linea); // stoi transforma la linea a un int
      nodos_habitaciones = new NodoMapa[total_habitaciones];

      for (int i = 0; i < total_habitaciones; i++) {
        getline(mapa, linea);

        size_t espacio = linea.find(" ");
        nodos_habitaciones[i].habitacion.numero =
            stoi(linea.substr(0, espacio)); // substr(posicion, total de
                                            // caracteres a sustraer)

        size_t parentesis = linea.find("(");
        nodos_habitaciones[i].habitacion.nombre =
            linea.substr(espacio + 1, parentesis - espacio - 2);

        size_t parentesis_final = linea.find(")");
        nodos_habitaciones[i].habitacion.tipo =
            linea.substr(parentesis + 1, parentesis_final - parentesis - 1);

        getline(mapa, linea);
        nodos_habitaciones[i].habitacion.descripcion = linea;
        if (true) {
        }
      }
    }

    else if (linea == "ARCOS") {
      int total_arcos;
      getline(mapa, linea);
      total_arcos = stoi(linea);

      for (int a = 0; a < total_arcos; a++) {
        getline(mapa, linea);

        size_t espacio = linea.find(" ");
        int desde = stoi(linea.substr(0, espacio));
        size_t flecha = linea.find("->");
        int hacia = stoi(linea.substr(flecha + 2));
        if (nodos_habitaciones[desde].hijo1 == nullptr) {
          nodos_habitaciones[desde].hijo1 = &(nodos_habitaciones[hacia]);
        } else if (nodos_habitaciones[desde].hijo2 == nullptr) {
          nodos_habitaciones[desde].hijo2 = &(nodos_habitaciones[hacia]);
        } else {
          nodos_habitaciones[desde].hijo3 = &(nodos_habitaciones[hacia]);
        }
      }
    }

    else if (linea == "ENEMIGOS") {
      getline(mapa, linea);
      total_enemigos = stoi(linea);
      enemigos_mapa = new enemigo[total_enemigos];

      for (int b = 0; b < total_enemigos; b++) {
        getline(mapa, linea);

        size_t separador1 = linea.find("|");
        size_t separador2 = linea.find("|", separador1 + 1);
        size_t separador3 = linea.find("|", separador2 + 1);
        size_t separador4 = linea.find("|", separador3 + 1);

        enemigos_mapa[b].nombre = linea.substr(0, separador1);
        enemigos_mapa[b].vida =
            stoi(linea.substr(separador1 + 7, separador2 - separador1 - 2));
        enemigos_mapa[b].ataque =
            stoi(linea.substr(separador2 + 8, separador3 - (separador2 + 8)));
        enemigos_mapa[b].precision =
            stof(linea.substr(separador3 + 12, separador4 - (separador3 + 12)));
        enemigos_mapa[b].probabilidad = stof(linea.substr(separador4 + 14));
      }
    } else if (linea == "EVENTOS") {
      int total_eventos;
      getline(mapa, linea);
      total_eventos = stoi(linea);
      Eventos *eventos_mapa = new Eventos[total_eventos];

      getline(mapa, linea);                     // se ubica en los &
      for (int c = 0; c < total_eventos; c++) { // c++ que chistoso miau
        getline(mapa, linea);                   // nombre de los eventos
        eventos_mapa[c].nombre = linea;
        getline(mapa, linea); // probabilidad de aparicion

        size_t espacio_probabilidad = linea.find(" ");
        eventos_mapa[c].probabilidad =
            stof(linea.substr(espacio_probabilidad + 1));

        getline(mapa, linea);
        eventos_mapa[c].descripcion = linea;
        getline(mapa, linea);

        int num_opcion = 0;
        do {
          eventos_mapa[c].opciones[num_opcion].accion = linea.substr(3);
          getline(mapa, linea);
          eventos_mapa[c].opciones[num_opcion].descripcion = linea;
          getline(mapa, linea);
          eventos_mapa[c].opciones[num_opcion].efecto = linea;
          num_opcion++;
          getline(mapa, linea);
        } while (linea != "&" && linea != "MEJORAS DE COMBATE");
      }
    }
    if (linea == "MEJORAS DE COMBATE") {
      getline(mapa, linea);
      while (linea != "FIN DE ARCHIVO") {
        mejoras_de_combate[indice_mejoras_de_combate++] = linea;
        getline(mapa, linea);
      }
    }
  }

  // NO OLVIDAR BORRAR MEMORIA CAUSA //

  mapa.close();
}

int main() {

  srand(time(0)); // Esta linea es para generar una seed aleatoria para
                  // los numeros random

  Jugador *jugador = new Jugador{30, 7, 0.95, 3};
  NodoMapa *nodos_habitaciones;
  leer_mapa("ejemplo.map", nodos_habitaciones);
  NodoMapa *nodo_habitacion_actual = &nodos_habitaciones[0];

  mostrar_generacion_texto(
      to_string(nodo_habitacion_actual->habitacion.numero) + " " +
      nodo_habitacion_actual->habitacion.nombre + " (" +
      nodo_habitacion_actual->habitacion.tipo + ")");

  mostrar_generacion_texto(nodo_habitacion_actual->habitacion.descripcion);

  usleep(500000); // medio segundo

  do {
    texto_elegir_siguiente_sala(nodo_habitacion_actual);
    mostrar_generacion_texto(
        to_string(nodo_habitacion_actual->habitacion.numero) + " " +
        nodo_habitacion_actual->habitacion.nombre + " (" +
        nodo_habitacion_actual->habitacion.tipo + ")");
    mostrar_generacion_texto(nodo_habitacion_actual->habitacion.descripcion);
    if (nodo_habitacion_actual->habitacion.tipo == "COMBATE") {
      empezar_combate(jugador, total_enemigos, enemigos_mapa);
    }

  } while (nodo_habitacion_actual->hijo1 != nullptr ||
           nodo_habitacion_actual->hijo2 != nullptr ||
           nodo_habitacion_actual->hijo3 != nullptr);

  return 0;
}
